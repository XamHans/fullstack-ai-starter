---
title: 'AI Web Search'
description: 'Deliver grounded answers by combining OpenAI web search preview and Google Gemini search tools.'
---

# Web Search Agent

Build an agent that can look up fresh information while keeping full control over the search experience. This starter ships with two options that work out of the box with the API keys already configured in `.env`:

1. OpenAI Responses API with the built-in `web_search_preview` tool
2. Google Gemini with the `google_search` tool

## Prerequisites

```env
OPENAI_API_KEY=sk-...
GOOGLE_AI_API_KEY=...
```

Both providers run through the shared `/api/ai/web-search` endpoint and can be toggled from the playground UI.

## Using native web search

### OpenAI Responses API

OpenAI's Responses API exposes a `web_search_preview` tool that delivers fast, cited answers.

```ts
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';

const { text, sources } = await generateText({
  model: openai.responses('gpt-4o-mini'),
  prompt: 'What happened in San Francisco last week?',
  tools: {
    web_search_preview: openai.tools.webSearchPreview({}),
  },
  stopWhen: stepCountIs(2),
});
```

### Google Gemini

Gemini models can ground their responses with Google search. The AI SDK exposes this through the `google_search` tool.

```ts
import { generateText, stepCountIs } from 'ai';
import { google } from '@ai-sdk/google';

const { text, sources, providerMetadata } = await generateText({
  model: google('gemini-2.5-flash'),
  prompt: 'List the top 5 San Francisco news from the past week.',
  tools: {
    google_search: google.tools.googleSearch({}),
  },
  stopWhen: stepCountIs(2),
});

const grounding = providerMetadata?.google?.groundingMetadata;
```

## API endpoint

The `/api/ai/web-search` route wraps both providers. It accepts a `query` along with an optional `provider` (`openai` or `google`) and returns the answer, sources, and any provider metadata.

```ts
// app/api/ai/web-search/route.ts
import { generateText, stepCountIs } from 'ai';
import { openai } from '@ai-sdk/openai';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { withAuth } from '@/lib/api/handlers';
import { parseRequestBody } from '@/lib/validation/parse';
import { withAITelemetry } from '@/lib/api/ai-utils';

const webSearchSchema = z.object({
  query: z.string().min(1),
  provider: z.enum(['openai', 'google']).default('openai'),
});

export const POST = withAuth(async (session, req) => {
  const bodyResult = await parseRequestBody(req, webSearchSchema);
  if (!bodyResult.success) return bodyResult;

  const { query, provider } = bodyResult.data;

  const result =
    provider === 'google'
      ? await generateText(
          withAITelemetry(
            {
              model: google('gemini-2.5-flash'),
              prompt: query,
              tools: { google_search: google.tools.googleSearch({}) },
              stopWhen: stepCountIs(2),
            },
            { functionId: 'web-search' },
          ),
        )
      : await generateText(
          withAITelemetry(
            {
              model: openai.responses('gpt-4o-mini'),
              prompt: query,
              tools: { web_search_preview: openai.tools.webSearchPreview({}) },
              stopWhen: stepCountIs(2),
            },
            { functionId: 'web-search' },
          ),
        );

  return {
    success: true,
    data: {
      provider,
      answer: result.text,
      sources: result.sources ?? [],
      providerMetadata: result.providerMetadata,
    },
  };
});
```

## Playground

- Navigate to **Playground â†’ Web Search** in the dashboard.
- Enter a question, choose **OpenAI** or **Google**, and submit.
- Review the streamed answer, citations, and (for Google) the raw grounding metadata.

This flow keeps the search logic in a single endpoint, so you can reuse it in agents, workflows, or server actions without duplicating provider-specific code.
