---
title: 'AI Text Generation'
description: 'Build powerful text generation features with multiple AI providers, streaming responses, and production-ready patterns'
---

# AI Text Generation

## What

Transform your application with AI-powered text generation capabilities. Create content, answer questions, and build intelligent features using OpenAI, Anthropic, and Google AI with built-in streaming, error handling, and observability.

## Why

- **Multi-Provider Flexibility**: Switch between OpenAI, Anthropic, and Google AI models
- **Real-time Streaming**: Users see text generating in real-time for better UX
- **Production Ready**: Built-in authentication, error handling, and performance tracking
- **Developer Friendly**: Type-safe integration with minimal setup

## How

### Quick Setup

1. **Add API Keys**

```env
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_AI_API_KEY=...
```

2. **Create API Endpoint**

```typescript
// app/api/ai/generate-text/route.ts
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';
import { withAuth } from '@/lib/api/handlers';
import { parseRequestBody } from '@/lib/validation/parse';

const generateSchema = z.object({
  prompt: z.string().min(1),
  model: z.string().default('gpt-3.5-turbo'),
});

export const POST = withAuth(async (session, request) => {
  const bodyResult = await parseRequestBody(request, generateSchema);
  if (!bodyResult.success) return bodyResult;

  const { text } = await generateText({
    model: openai(bodyResult.data.model),
    prompt: bodyResult.data.prompt,
  });

  return { success: true, data: { text } };
});
```

3. **Build Frontend Component**

```tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';

export function TextGenerator() {
  const [prompt, setPrompt] = useState('');
  const [result, setResult] = useState('');
  const [loading, setLoading] = useState(false);

  const generateText = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/ai/generate-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt }),
      });
      const data = await response.json();
      setResult(data.text);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-4">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="Describe what you want to generate..."
        rows={4}
      />
      <Button onClick={generateText} disabled={loading || !prompt}>
        {loading ? 'Generating...' : 'Generate Text'}
      </Button>
      {result && (
        <div className="p-4 bg-gray-50 rounded-lg">
          <p className="whitespace-pre-wrap">{result}</p>
        </div>
      )}
    </div>
  );
}
```

## Example

### Streaming Text Generation

For real-time user feedback, implement streaming responses:

```typescript
// app/api/ai/generate-text-stream/route.ts
import { streamText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';
import { auth } from '@/lib/auth';
import { parseRequestBody } from '@/lib/validation/parse';
import { handleResult } from '@/lib/api/handlers';

const streamSchema = z.object({
  prompt: z.string().min(1),
});

// Note: Streaming endpoints return DataStreamResponse directly
export async function POST(request: Request) {
  const session = await auth.api.getSession({ headers: request.headers });
  if (!session) {
    return handleResult({ success: false, error: { code: 'UNAUTHORIZED', message: 'Authentication required' } });
  }

  const bodyResult = await parseRequestBody(request, streamSchema);
  if (!bodyResult.success) return handleResult(bodyResult);

  const result = await streamText({
    model: openai('gpt-3.5-turbo'),
    prompt: bodyResult.data.prompt,
  });

  return result.toDataStreamResponse();
}
```

```tsx
'use client';

import { useCompletion } from 'ai/react';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';

export function StreamingTextGenerator() {
  const { completion, input, setInput, handleSubmit, isLoading } =
    useCompletion({
      api: '/api/ai/generate-text-stream',
    });

  return (
    <div className="space-y-4">
      <form onSubmit={handleSubmit}>
        <Textarea
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Enter your prompt for streaming generation..."
          rows={3}
        />
        <Button type="submit" disabled={isLoading} className="mt-2">
          {isLoading ? 'Generating...' : 'Generate Stream'}
        </Button>
      </form>

      {completion && (
        <div className="p-4 bg-gray-50 rounded-lg">
          <p className="whitespace-pre-wrap">{completion}</p>
        </div>
      )}
    </div>
  );
}
```

### Advanced Features

**Multiple AI Providers**

```typescript
import { openai } from '@ai-sdk/openai';
import { anthropic } from '@ai-sdk/anthropic';
import { google } from '@ai-sdk/google';
import { z } from 'zod';
import { withAuth } from '@/lib/api/handlers';
import { parseRequestBody } from '@/lib/validation/parse';

const models = {
  'gpt-4': openai('gpt-4'),
  'claude-3.5-sonnet': anthropic('claude-3-5-sonnet-20241022'),
  'gemini-pro': google('models/gemini-pro'),
} as const;

const multiProviderSchema = z.object({
  prompt: z.string().min(1),
  provider: z.enum(['gpt-4', 'claude-3.5-sonnet', 'gemini-pro']).default('gpt-4'),
});

export const POST = withAuth(async (session, request) => {
  const bodyResult = await parseRequestBody(request, multiProviderSchema);
  if (!bodyResult.success) return bodyResult;

  const { prompt, provider } = bodyResult.data;

  const { text } = await generateText({
    model: models[provider],
    prompt,
  });

  return { success: true, data: { text, provider } };
});
```

**With Error Handling**

```tsx
export function RobustTextGenerator() {
  const [prompt, setPrompt] = useState('');
  const [result, setResult] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleGenerate = async () => {
    if (!prompt.trim()) return;

    setLoading(true);
    setError('');

    try {
      const response = await fetch('/api/ai/generate-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt }),
      });

      const data = await response.json();

      if (data.success) {
        setResult(data.data.text);
        setPrompt(''); // Clear on success
      } else {
        setError(data.error || 'Generation failed');
      }
    } catch (err) {
      setError('Network error. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto space-y-4">
      <Textarea
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="What would you like me to write?"
        rows={4}
      />

      <Button
        onClick={handleGenerate}
        disabled={loading || !prompt.trim()}
        className="w-full"
      >
        {loading ? 'Generating...' : 'Generate Text'}
      </Button>

      {error && (
        <div className="p-3 bg-red-50 border border-red-200 rounded text-red-700">
          {error}
        </div>
      )}

      {result && (
        <div className="p-4 bg-blue-50 rounded-lg">
          <h3 className="font-medium mb-2">Generated Text:</h3>
          <p className="whitespace-pre-wrap">{result}</p>
        </div>
      )}
    </div>
  );
}
```

## Supported Models

| Provider      | Models               | Best For                                      |
| ------------- | -------------------- | --------------------------------------------- |
| **OpenAI**    | GPT-4, GPT-3.5-turbo | General purpose, coding, analysis             |
| **Anthropic** | Claude 3.5 Sonnet    | Long-form content, research, creative writing |
| **Google AI** | Gemini Pro           | Multimodal tasks, reasoning, factual content  |

## Interactive Playground

Test different prompts and models at `/playground/generate-text/generate-text` to see text generation in action.

## Next Steps

- **Add Chat Interface**: Build conversational AI with `/ai-chat`
- **Implement Observability**: Track usage and costs with `/observability`
- **Follow Best Practices**: Optimize performance with `/ai-best-practices`
