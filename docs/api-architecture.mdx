---
title: "API Architecture"
description: "Robust API pattern with Result-based error handling, authentication wrappers, and functional programming principles"
---

# API Architecture

## What

A robust API pattern built on Next.js 16 Route Handlers with explicit error handling using the `Result<T>` type, Zod validation, and consistent response formatting. The pattern uses higher-order functions (`withAuth`, `withHandler`) to abstract authentication while keeping error states explicit.

## Why

- **Explicit Errors**: `Result<T>` type makes success/failure visible in the type system
- **Type-Safe Validation**: Zod schemas ensure request data matches expected shapes
- **Consistency**: All endpoints return standardized JSON responses
- **Security**: Authentication is handled through reusable wrappers
- **DRY Principle**: Common logic is centralized, not repeated in every route

## How

### Core Components

1. **`Result<T>` Type**: Explicit success/error returns (`lib/result.ts`)
2. **ErrorCode Enum**: Centralized error codes with status mapping (`lib/errors.ts`)
3. **Handler Functions**: `withAuth` and `withHandler` wrappers (`lib/api/handlers.ts`)
4. **Zod Validation**: Schema-based request validation (`lib/validation/parse.ts`)

### Implementation Steps

1. Define Zod schemas in `modules/{domain}/schemas.ts`
2. Create API routes using `withAuth` or `withHandler` wrappers
3. Validate requests with `parseRequestBody` and `parseSearchParams`
4. Return `Result<T>` from service methods
5. Handlers automatically convert results to HTTP responses

### API Response Structure

All responses follow this format:

**Success Response:**
```typescript
{
  success: true;
  data: T;  // The actual response data
}
```

**Error Response:**
```typescript
{
  success: false;
  code: string;      // Error code (e.g., "POST_NOT_FOUND")
  error: string;     // Human-readable message
  details?: object;  // Optional validation details
}
```

### Error Codes

Error codes are defined in `lib/errors.ts` with exhaustive HTTP status mapping:

```typescript
export const ErrorCode = {
  // Validation (400)
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  INVALID_JSON: 'INVALID_JSON',

  // Auth (401/403)
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',

  // Not Found (404)
  NOT_FOUND: 'NOT_FOUND',
  POST_NOT_FOUND: 'POST_NOT_FOUND',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  PAYMENT_NOT_FOUND: 'PAYMENT_NOT_FOUND',

  // Server (500/502)
  DATABASE_ERROR: 'DATABASE_ERROR',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  EXTERNAL_SERVICE_ERROR: 'EXTERNAL_SERVICE_ERROR',
} as const;

// HTTP status codes are centralized
export const errorCodeToStatus: Record<ErrorCode, number> = {
  VALIDATION_ERROR: 400,
  INVALID_JSON: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  POST_NOT_FOUND: 404,
  // ... etc
};
```

## Example

### 1. Define Zod Schema

```typescript
// modules/posts/schemas.ts
import { z } from 'zod';

export const createPostSchema = z.object({
  title: z.string().min(1, 'Title required').max(200),
  content: z.string().min(1, 'Content required'),
  published: z.boolean().default(false),
});

export const updatePostSchema = createPostSchema.partial();

export type CreatePostSchema = z.infer<typeof createPostSchema>;
export type UpdatePostSchema = z.infer<typeof updatePostSchema>;
```

### 2. Service with `Result<T>` Returns

```typescript
// modules/posts/services/post.service.ts
import type { Result } from '@/lib/result';
import type { Post } from '../types';

export class PostService {
  constructor(private deps: ServiceDependencies) {}

  async getById(id: string): Promise<Result<Post>> {
    try {
      const [post] = await this.deps.db
        .select()
        .from(posts)
        .where(eq(posts.id, id));

      if (!post) {
        return {
          success: false,
          error: { code: 'POST_NOT_FOUND', message: 'Post not found' }
        };
      }

      return { success: true, data: post };
    } catch (error) {
      return {
        success: false,
        error: { code: 'DATABASE_ERROR', message: 'Failed to fetch post', cause: error }
      };
    }
  }

  async createPost(data: CreatePostSchema, userId: string): Promise<Result<Post>> {
    try {
      const [post] = await this.deps.db
        .insert(posts)
        .values({ ...data, authorId: userId })
        .returning();

      return { success: true, data: post };
    } catch (error) {
      return {
        success: false,
        error: { code: 'DATABASE_ERROR', message: 'Failed to create post', cause: error }
      };
    }
  }
}
```

### 3. Public API Route

```typescript
// app/api/posts/route.ts
import { withHandler } from '@/lib/api/handlers';
import { parseSearchParams } from '@/lib/validation/parse';
import { withServices } from '@/lib/container/utils';
import { z } from 'zod';

const listQuerySchema = z.object({
  limit: z.coerce.number().optional().default(10),
  offset: z.coerce.number().optional().default(0),
  search: z.string().optional(),
});

export const GET = withHandler(async (req) => {
  // Validate query params
  const paramsResult = parseSearchParams(req.url, listQuerySchema);
  if (!paramsResult.success) return paramsResult;

  // Call service
  const { postService } = withServices('postService');
  return postService.getPosts(paramsResult.data);
});
```

### 4. Protected API Route

```typescript
// app/api/posts/route.ts (continued)
import { withAuth } from '@/lib/api/handlers';
import { parseRequestBody } from '@/lib/validation/parse';
import { createPostSchema } from '@/modules/posts/schemas';

export const POST = withAuth(async (session, req) => {
  // Validate request body
  const bodyResult = await parseRequestBody(req, createPostSchema);
  if (!bodyResult.success) return bodyResult;

  // Call service with validated data and user ID
  const { postService } = withServices('postService');
  return postService.createPost(bodyResult.data, session.user.id);
});
```

### 5. Dynamic Route with Params

```typescript
// app/api/posts/[id]/route.ts
import { withAuth } from '@/lib/api/handlers';
import { parseRequestBody } from '@/lib/validation/parse';
import { withServices } from '@/lib/container/utils';
import { updatePostSchema } from '@/modules/posts/schemas';

// GET /api/posts/[id]
export const GET = withAuth(async (session, req, ctx) => {
  // IMPORTANT: Await params in Next.js 15+
  const params = await ctx.params;
  const id = params?.id as string;

  const { postService } = withServices('postService');
  return postService.getById(id);
});

// PUT /api/posts/[id]
export const PUT = withAuth(async (session, req, ctx) => {
  const params = await ctx.params;
  const id = params?.id as string;

  const bodyResult = await parseRequestBody(req, updatePostSchema);
  if (!bodyResult.success) return bodyResult;

  const { postService } = withServices('postService');
  return postService.updatePost(id, bodyResult.data, session.user.id);
});

// DELETE /api/posts/[id]
export const DELETE = withAuth(async (session, req, ctx) => {
  const params = await ctx.params;
  const id = params?.id as string;

  const { postService } = withServices('postService');
  return postService.deletePost(id, session.user.id);
});
```

### 6. Validation Helpers

```typescript
// lib/validation/parse.ts
import type { z } from 'zod';
import type { Result } from '@/lib/result';

// Validate request body with Zod schema
export async function parseRequestBody<T extends z.ZodSchema>(
  request: Request,
  schema: T,
): Promise<Result<z.infer<T>>> {
  let json: unknown;

  try {
    json = await request.json();
  } catch {
    return {
      success: false,
      error: { code: 'INVALID_JSON', message: 'Invalid JSON body' },
    };
  }

  return parseWith(schema, json);
}

// Validate URL search params with Zod schema
export function parseSearchParams<T extends z.ZodSchema>(
  url: string,
  schema: T,
): Result<z.infer<T>> {
  const { searchParams } = new URL(url);
  return parseWith(schema, Object.fromEntries(searchParams));
}

// Generic Zod validation returning Result<T>
export function parseWith<T extends z.ZodSchema>(
  schema: T,
  data: unknown
): Result<z.infer<T>> {
  const result = schema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  return {
    success: false,
    error: {
      code: 'VALIDATION_ERROR',
      message: 'Validation failed',
      details: {
        issues: result.error.issues.map((i) => ({
          path: i.path.join('.'),
          message: i.message,
        })),
      },
    },
  };
}
```

## Request Flow

1. **Request Received**: Next.js Route Handler processes the request
2. **Authentication Check**: `withAuth` wrapper verifies session (if required)
3. **Validation**: Zod schema validates request body/params
4. **Service Call**: Handler calls service which returns `Result<T>`
5. **Response Conversion**: `handleResult` converts `Result<T>` to HTTP response
6. **Response Sent**: Standardized JSON response sent to client

## Handler Implementation

```typescript
// lib/api/handlers.ts
import { type NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { errorCodeToStatus } from '@/lib/errors';
import type { Result } from '@/lib/result';

// Convert Result<T> to HTTP Response
export function handleResult<T>(
  result: Result<T>,
  successStatus = 200,
): NextResponse {
  if (result.success) {
    return NextResponse.json(
      { success: true, data: result.data },
      { status: successStatus }
    );
  }

  const { code, message, details } = result.error;
  const status = errorCodeToStatus[code];

  // Log cause server-side (don't send to client)
  if (result.error.cause) {
    console.error(`[${code}]`, result.error.cause);
  }

  return NextResponse.json(
    { success: false, code, error: message, details },
    { status }
  );
}

// Authenticated route handler
export function withAuth<T>(
  handler: (session: Session, req: NextRequest, ctx: RouteContext) => Promise<Result<T>>,
) {
  return async (req: NextRequest, ctx: RouteContext) => {
    const session = await auth.api.getSession({ headers: req.headers });

    if (!session) {
      return handleResult<T>({
        success: false,
        error: { code: 'UNAUTHORIZED', message: 'Authentication required' },
      });
    }

    const result = await handler(session, req, ctx);
    return handleResult(result);
  };
}

// Public route handler
export function withHandler<T>(
  handler: (req: NextRequest, ctx: RouteContext) => Promise<Result<T>>,
) {
  return async (req: NextRequest, ctx: RouteContext) => {
    const result = await handler(req, ctx);
    return handleResult(result);
  };
}
```

## Client-Side Usage with TanStack Query

```typescript
// modules/posts/hooks/use-posts.ts
'use client';

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

async function fetchApi<T>(url: string, options?: RequestInit): Promise<T> {
  const res = await fetch(url, {
    headers: { 'Content-Type': 'application/json' },
    ...options,
  });
  const json = await res.json();
  if (!json.success) throw new Error(json.error);
  return json.data;
}

export function usePosts(filters?: { search?: string }) {
  const params = new URLSearchParams();
  if (filters?.search) params.set('search', filters.search);

  return useQuery({
    queryKey: ['posts', filters],
    queryFn: () => fetchApi<Post[]>(`/api/posts?${params}`),
  });
}

export function useCreatePost() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: (data: CreatePostInput) =>
      fetchApi<Post>('/api/posts', { method: 'POST', body: JSON.stringify(data) }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['posts'] }),
  });
}
```

## Key Differences from Previous Pattern

| Aspect | Before (Deprecated) | After (Current) |
|--------|---------------------|-----------------|
| Error handling | `throw new ApiError(...)` | `return { success: false, error: {...} }` |
| Validation | `validateRequiredFields()` | Zod schemas + `parseRequestBody()` |
| Service returns | `T` (throws on error) | `Result<T>` (explicit) |
| API handlers | `withErrorHandling` + `withAuthentication` | `withHandler` + `withAuth` |
| Status codes | Scattered in `ApiError` calls | Centralized `errorCodeToStatus` |
| Client fetching | `useState` + `useEffect` + `fetch` | TanStack Query hooks |
| Reference file | `lib/api/base.ts` | `lib/api/handlers.ts` |

## Best Practices

1. **Always use Zod schemas** for request validation
2. **Return `Result<T>`** from service methods, never throw
3. **Await params** in Next.js 15+ dynamic routes
4. **Use error codes** from `lib/errors.ts`, add new codes as needed
5. **Use TanStack Query** for client-side data fetching
6. **Include `cause`** in errors for server-side logging
