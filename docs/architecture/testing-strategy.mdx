---
title: "Testing Strategy"
description: "Comprehensive testing approach using Vitest and Supertest for Next.js 15 application with PostgreSQL, Drizzle ORM, and modular service architecture."
---

# Testing Strategy with Vitest & Supertest

## Overview

Comprehensive testing strategy for the AI Starter Kit using Vitest for unit/integration tests, Supertest for API testing, and Testing Library for component testing. The strategy ensures reliability and maintainability across the modular service architecture with PostgreSQL database and external AI integrations.

## Project Architecture

### Tech Stack
- **Framework**: Next.js 15 with App Router
- **Database**: PostgreSQL with Drizzle ORM
- **Authentication**: Better Auth
- **Services**: Modular architecture with dependency injection
- **External APIs**: Google Gemini AI, Cloudflare R2 Storage
- **Logging**: Structured logging with Pino

### Testing Stack

#### Core Testing Libraries
```json
{
  "devDependencies": {
    "vitest": "latest",
    "supertest": "latest",
    "@testing-library/react": "latest",
    "@testing-library/jest-dom": "^6.7.0",
    "@testing-library/dom": "latest",
    "msw": "latest",
    "@testcontainers/postgresql": "latest",
    "happy-dom": "latest",
    "jsdom": "latest"
  }
}
```

#### Package.json Scripts
```json
{
  "scripts": {
    "test": "vitest",
    "test:integration": "vitest --config ./vitest.integration.config.ts",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage",
    "test:watch": "vitest --watch"
  }
}
```

## Vitest Configuration

### Unit Test Configuration
```typescript
// vitest.config.ts
import { resolve } from 'path';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  plugins: [],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    exclude: ['**/node_modules/**', '**/dist/**', '**/*.integration.test.*'],
    hookTimeout: 30000,
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './'),
    },
  },
});
```

### Integration Test Configuration
```typescript
// vitest.integration.config.ts
import { resolve } from 'path';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'node',
    globals: true,
    setupFiles: ['./tests/setup.ts'],
    include: ['**/tests/**/*.integration.test.ts'],
    testTimeout: 30000,
    hookTimeout: 60000,
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, './'),
    },
  },
});
```

## Test Setup and Configuration

### Global Test Setup
```typescript
// tests/setup.ts
import { setupServer } from 'msw/node';
import { afterAll, beforeAll, beforeEach } from 'vitest';
import { handlers } from './mocks/handlers';
import '@testing-library/jest-dom';

// Setup MSW server for API mocking
export const server = setupServer(...handlers);

beforeAll(() => {
  server.listen({ onUnhandledRequest: 'bypass' });
});

afterAll(() => {
  server.close();
});

beforeEach(() => {
  server.resetHandlers();
});
```

### Mock Service Worker (MSW) Handlers
```typescript
// tests/mocks/handlers.ts
import { HttpResponse, http } from 'msw';

export const handlers = [
  // Mock Gemini AI API
  http.post('https://generativelanguage.googleapis.com/v1beta/*', () => {
    return HttpResponse.json({
      candidates: [{ content: { parts: [{ text: 'Mock AI response' }] } }],
    });
  }),

  // Mock Cloudflare R2 Storage
  http.put('https://*.r2.cloudflarestorage.com/*', () => {
    return HttpResponse.text('', { status: 200 });
  }),

  // Mock API routes for component tests
  http.get('/api/posts', () => {
    return HttpResponse.json({
      posts: [
        {
          id: '1',
          title: 'Test Post',
          content: 'Test content',
          published: true,
          authorId: 'user-1',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
      ],
    });
  }),

  http.post('/api/posts', async ({ request }) => {
    const body = await request.json();
    return HttpResponse.json(
      {
        id: 'new-post-id',
        ...body,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      },
      { status: 201 }
    );
  }),
];
```

## Database Testing Strategy

### PostgreSQL Test Container Setup
```typescript
// tests/utils/test-database.ts
import { PostgreSqlContainer } from '@testcontainers/postgresql';
import { drizzle } from 'drizzle-orm/postgres-js';
import { migrate } from 'drizzle-orm/postgres-js/migrator';
import postgres from 'postgres';
import { schema } from '@/lib/db';

let container: PostgreSqlContainer;
let testDb: any;

export async function setupTestDatabase() {
  // Start PostgreSQL container
  container = await new PostgreSqlContainer('postgres:15')
    .withDatabase('test_db')
    .withUsername('test_user')
    .withPassword('test_password')
    .start();

  // Create database connection
  const connectionString = container.getConnectionUri();
  const client = postgres(connectionString);
  testDb = drizzle(client, { schema });

  try {
    await migrate(testDb, { migrationsFolder: './lib/db/migrations' });
  } catch (error) {
    console.warn('No migrations found, continuing with empty database');
  }

  return testDb;
}

export async function teardownTestDatabase() {
  if (container) {
    await container.stop();
  }
}

export function getTestDb() {
  if (!testDb) {
    console.warn('Test database not initialized, using mock database');
    return null;
  }
  return testDb;
}

export async function cleanTestDatabase() {
  if (testDb) {
    // Clean all tables in reverse dependency order
    await testDb.delete(schema.posts);
    await testDb.delete(schema.users);
  }
}
```

### Test Container for Dependency Injection
```typescript
// tests/utils/test-container.ts
import { vi } from 'vitest';
import type { Container } from '@/lib/container';
import type { DatabaseConnection, ServiceDependencies } from '@/lib/container/types';
import { createLogger } from '@/lib/logger';
import { PostService } from '@/modules/posts/services/post.service';
import { UserService } from '@/modules/users/services/user.service';
import { getTestDb } from './test-database';

export function createTestContainer(): Container & {
  dependencies: { db: any };
} {
  // Use real test database if available, otherwise use simple mock database
  const testDb = getTestDb();

  const testDatabase: DatabaseConnection = {
    db: testDb,
  };

  // Create a quieter logger for tests
  const originalLogLevel = process.env.LOG_LEVEL;
  process.env.LOG_LEVEL = 'error'; // Only show errors in tests
  const testLogger = createLogger();
  process.env.LOG_LEVEL = originalLogLevel; // Restore original log level

  // Create service dependencies with test logger
  const serviceDependencies: ServiceDependencies = {
    db: testDb,
    logger: testLogger,
    services: undefined, // Will be set after services are created
  };

  // Create services manually with test dependencies
  const userService = new UserService(serviceDependencies);
  const postService = new PostService(serviceDependencies);

  // Update service dependencies with service references
  serviceDependencies.services = { userService, postService };

  const container: Container = {
    database: testDatabase,
    externalServices: {
      geminiClient: {
        generateVideo: vi.fn().mockResolvedValue({ jobId: 'test-job-123' }),
        checkJobStatus: vi.fn().mockResolvedValue({
          status: 'completed',
          videoUrl: 'test-url'
        }),
      },
      r2Client: {
        uploadVideo: vi.fn().mockResolvedValue({ url: 'test-upload-url' }),
        deleteVideo: vi.fn().mockResolvedValue(true),
      },
    },
    userService,
    postService,
  };

  return {
    ...container,
    dependencies: {
      db: testDb,
    },
  };
}
```

## Service Layer Testing

### Service Unit Tests
```typescript
// modules/posts/tests/post.service.test.ts
import { afterAll, beforeAll, beforeEach, describe, expect, it } from 'vitest';
import { createTestContainer } from '@/tests/utils/test-container';
import {
  cleanTestDatabase,
  setupTestDatabase,
  teardownTestDatabase,
} from '@/tests/utils/test-database';
import type { PostService } from '../services/post.service';

describe('PostService', () => {
  let postService: PostService;
  let testContainer: ReturnType<typeof createTestContainer>;

  beforeAll(async () => {
    try {
      await setupTestDatabase();
    } catch (error) {
      console.warn('Docker not available, using mock database');
    }
  });

  afterAll(async () => {
    try {
      await teardownTestDatabase();
    } catch (error) {
      // Ignore teardown errors when using mock database
    }
  });

  beforeEach(async () => {
    try {
      await cleanTestDatabase();
    } catch (error) {
      // Ignore cleanup errors when using mock database
    }
    testContainer = createTestContainer();
    postService = testContainer.postService;
  });

  describe('createPost', () => {
    it('should create a new post', async () => {
      const postData = {
        title: 'Test Post',
        content: 'This is a test post content',
        published: false,
      };
      const authorId = 'test-author-id';

      const post = await postService.createPost(postData, authorId);

      expect(post).toMatchObject({
        title: postData.title,
        content: postData.content,
        published: postData.published,
        authorId: authorId,
      });
      expect(post.id).toBeDefined();
      expect(post.createdAt).toBeDefined();
      expect(post.updatedAt).toBeDefined();
    });

    it('should create a published post', async () => {
      const postData = {
        title: 'Published Test Post',
        content: 'This is a published test post',
        published: true,
      };
      const authorId = 'test-author-id';

      const post = await postService.createPost(postData, authorId);

      expect(post.published).toBe(true);
      expect(post.title).toBe(postData.title);
      expect(post.authorId).toBe(authorId);
    });
  });

  describe('getPostById', () => {
    it('should find post by id', async () => {
      const postData = {
        title: 'Test Post',
        content: 'This is a test post content',
        published: true,
      };
      const authorId = 'test-author-id';

      const createdPost = await postService.createPost(postData, authorId);
      const foundPost = await postService.getPostById(createdPost.id);

      expect(foundPost).toMatchObject({
        id: createdPost.id,
        title: postData.title,
        content: postData.content,
        published: postData.published,
        authorId: authorId,
      });
    });

    it('should return undefined for non-existent post', async () => {
      const foundPost = await postService.getPostById('non-existent-id');
      expect(foundPost).toBeUndefined();
    });
  });

  describe('getPosts', () => {
    beforeEach(async () => {
      // Create some test posts
      const authorId = 'test-author-id';

      await postService.createPost(
        {
          title: 'Published Post 1',
          content: 'Content 1',
          published: true,
        },
        authorId,
      );

      await postService.createPost(
        {
          title: 'Published Post 2',
          content: 'Content 2',
          published: true,
        },
        authorId,
      );

      await postService.createPost(
        {
          title: 'Draft Post',
          content: 'Draft content',
          published: false,
        },
        authorId,
      );
    });

    it('should return only published posts by default', async () => {
      const posts = await postService.getPosts();

      expect(posts).toHaveLength(2);
      posts.forEach((post) => {
        expect(post.published).toBe(true);
      });
    });

    it('should respect limit parameter', async () => {
      const posts = await postService.getPosts({ limit: 1 });

      expect(posts).toHaveLength(1);
      expect(posts[0].published).toBe(true);
    });

    it('should filter by search term', async () => {
      const posts = await postService.getPosts({ search: 'Post 1' });

      expect(posts).toHaveLength(1);
      expect(posts[0].title).toBe('Published Post 1');
    });
  });
});
```

## API Testing with Supertest

### Next.js App Router API Testing
```typescript
// tests/api/posts.api.test.ts
import { describe, it, expect, beforeEach, afterAll, beforeAll } from 'vitest';
import request from 'supertest';
import { createServer } from 'http';
import { NextRequest } from 'next/server';
import { GET, POST } from '@/app/api/posts/route';
import { setupTestDatabase, teardownTestDatabase, cleanTestDatabase } from '@/tests/utils/test-database';

// Create test server for Next.js App Router
const createTestServer = () => {
  return createServer(async (req, res) => {
    const url = new URL(req.url!, `http://${req.headers.host}`);
    const nextReq = new NextRequest(url, {
      method: req.method,
      headers: req.headers as any,
      body: req.method !== 'GET' ? req : undefined,
    });

    let response;
    if (req.method === 'GET') {
      response = await GET(nextReq);
    } else if (req.method === 'POST') {
      response = await POST(nextReq);
    }

    if (response) {
      res.writeHead(response.status, Object.fromEntries(response.headers));
      if (response.body) {
        const reader = response.body.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          res.write(value);
        }
      }
      res.end();
    }
  });
};

describe('Posts API Integration Tests', () => {
  let server: any;

  beforeAll(async () => {
    try {
      await setupTestDatabase();
    } catch (error) {
      console.warn('Docker not available, using mock database');
    }
  });

  afterAll(async () => {
    try {
      await teardownTestDatabase();
    } catch (error) {
      // Ignore teardown errors
    }
  });

  beforeEach(async () => {
    try {
      await cleanTestDatabase();
    } catch (error) {
      // Ignore cleanup errors when using mock database
    }
    server = createTestServer();
  });

  afterEach(() => {
    server?.close();
  });

  describe('GET /api/posts', () => {
    it('should return empty array when no posts exist', async () => {
      const response = await request(server)
        .get('/api/posts')
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body).toHaveLength(0);
    });

    it('should return posts with pagination', async () => {
      // First create some posts through the service
      // (This would require setting up the service or using direct database insertion)

      const response = await request(server)
        .get('/api/posts?limit=5&offset=0')
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
    });

    it('should filter posts by search term', async () => {
      const response = await request(server)
        .get('/api/posts?search=test')
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
    });
  });

  describe('POST /api/posts', () => {
    it('should create a new post with valid data', async () => {
      const postData = {
        title: 'New Test Post',
        content: 'This is test content',
        published: false,
      };

      const response = await request(server)
        .post('/api/posts')
        .send(postData)
        .expect(201);

      expect(response.body).toMatchObject({
        title: postData.title,
        content: postData.content,
        published: postData.published,
      });
      expect(response.body.id).toBeDefined();
      expect(response.body.createdAt).toBeDefined();
    });

    it('should validate required fields', async () => {
      const invalidData = {
        content: 'Missing title',
      };

      const response = await request(server)
        .post('/api/posts')
        .send(invalidData)
        .expect(400);

      expect(response.body).toHaveProperty('error');
    });

    it('should require authentication', async () => {
      // Mock unauthenticated request
      const postData = {
        title: 'Test Post',
        content: 'Test content',
      };

      const response = await request(server)
        .post('/api/posts')
        .send(postData)
        .expect(401);

      expect(response.body).toHaveProperty('error');
    });
  });
});
```

## Component Testing

### React Component Testing Setup
```typescript
// tests/utils/component-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement } from 'react';

// Test providers wrapper
interface ProvidersProps {
  children: React.ReactNode;
}

function TestProviders({ children }: ProvidersProps) {
  return (
    <div data-testid="test-provider">
      {children}
    </div>
  );
}

// Custom render function
interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {}

export function renderWithProviders(
  ui: ReactElement,
  options: CustomRenderOptions = {}
) {
  return render(ui, {
    wrapper: ({ children }) => (
      <TestProviders>
        {children}
      </TestProviders>
    ),
    ...options,
  });
}

// Re-export everything
export * from '@testing-library/react';
export { default as userEvent } from '@testing-library/user-event';
```

### Component Test Example
```typescript
// components/posts/post-card.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PostCard } from './post-card';
import { renderWithProviders } from '@/tests/utils/component-utils';

const mockPost = {
  id: '1',
  title: 'Test Post Title',
  content: 'Test post content',
  published: true,
  authorId: 'user-1',
  createdAt: new Date('2024-01-01T10:00:00Z'),
  updatedAt: new Date('2024-01-01T10:00:00Z'),
};

describe('PostCard', () => {
  const defaultProps = {
    post: mockPost,
    onEdit: vi.fn(),
    onDelete: vi.fn(),
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders post title and content', () => {
    renderWithProviders(<PostCard {...defaultProps} />);

    expect(screen.getByText('Test Post Title')).toBeInTheDocument();
    expect(screen.getByText('Test post content')).toBeInTheDocument();
  });

  it('shows published status', () => {
    renderWithProviders(<PostCard {...defaultProps} />);

    expect(screen.getByText('Published')).toBeInTheDocument();
  });

  it('shows draft status for unpublished posts', () => {
    const draftPost = { ...mockPost, published: false };

    renderWithProviders(
      <PostCard {...defaultProps} post={draftPost} />
    );

    expect(screen.getByText('Draft')).toBeInTheDocument();
  });

  it('handles edit button click', async () => {
    const user = userEvent.setup();
    const onEdit = vi.fn();

    renderWithProviders(
      <PostCard {...defaultProps} onEdit={onEdit} />
    );

    const editButton = screen.getByRole('button', { name: /edit/i });
    await user.click(editButton);

    expect(onEdit).toHaveBeenCalledWith(mockPost.id);
  });

  it('handles delete button click', async () => {
    const user = userEvent.setup();
    const onDelete = vi.fn();

    renderWithProviders(
      <PostCard {...defaultProps} onDelete={onDelete} />
    );

    const deleteButton = screen.getByRole('button', { name: /delete/i });
    await user.click(deleteButton);

    expect(onDelete).toHaveBeenCalledWith(mockPost.id);
  });

  it('formats date correctly', () => {
    renderWithProviders(<PostCard {...defaultProps} />);

    // Should show formatted date
    expect(screen.getByText(/Jan 1, 2024/i)).toBeInTheDocument();
  });
});
```

## Integration Testing Patterns

### Full Stack Integration Test
```typescript
// tests/integration/posts-flow.integration.test.ts
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { createTestContainer } from '@/tests/utils/test-container';
import { setupTestDatabase, teardownTestDatabase, cleanTestDatabase } from '@/tests/utils/test-database';

describe('Posts Integration Flow', () => {
  let testContainer: ReturnType<typeof createTestContainer>;

  beforeAll(async () => {
    await setupTestDatabase();
  });

  afterAll(async () => {
    await teardownTestDatabase();
  });

  beforeEach(async () => {
    await cleanTestDatabase();
    testContainer = createTestContainer();
  });

  it('should complete full post lifecycle', async () => {
    const { postService, userService } = testContainer;

    // Create a user first
    const userData = {
      email: 'test@example.com',
      name: 'Test User',
    };
    const user = await userService.createUser(userData);

    // Create a post
    const postData = {
      title: 'Integration Test Post',
      content: 'This is an integration test',
      published: false,
    };
    const post = await postService.createPost(postData, user.id);

    expect(post).toMatchObject({
      title: postData.title,
      content: postData.content,
      published: false,
      authorId: user.id,
    });

    // Update the post
    const updatedPost = await postService.updatePost(post.id, {
      published: true,
    });

    expect(updatedPost.published).toBe(true);

    // Retrieve published posts
    const publishedPosts = await postService.getPosts();
    expect(publishedPosts).toHaveLength(1);
    expect(publishedPosts[0].id).toBe(post.id);

    // Delete the post
    await postService.deletePost(post.id);

    // Verify deletion
    const foundPost = await postService.getPostById(post.id);
    expect(foundPost).toBeUndefined();
  });
});
```

## Coverage and Quality Gates

### Coverage Configuration
```typescript
// vitest.config.ts (coverage section)
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      reportsDirectory: './coverage',
      exclude: [
        'node_modules/',
        'tests/',
        '.next/',
        'coverage/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/types/**',
        '**/mocks/**',
      ],
      include: [
        'app/**/*.{ts,tsx}',
        'components/**/*.{ts,tsx}',
        'lib/**/*.{ts,tsx}',
        'modules/**/*.{ts,tsx}',
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80,
        },
        'modules/': {
          branches: 90,
          functions: 90,
          lines: 90,
          statements: 90,
        },
      },
    },
  },
});
```

### GitHub Actions CI
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test -- --run
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Run integration tests
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db

      - name: Generate coverage
        run: npm run test:coverage
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
```

## Testing Best Practices

### 1. Test Organization
- **Unit Tests**: Test individual functions and classes in isolation
- **Integration Tests**: Test service interactions and database operations
- **API Tests**: Test HTTP endpoints with Supertest
- **Component Tests**: Test React components with user interactions

### 2. Naming Conventions
```
tests/
├── utils/                    # Test utilities
├── mocks/                    # MSW handlers and mocks
└── integration/              # Integration test suites

modules/
└── [module]/
    └── tests/               # Unit tests for module
        ├── [service].test.ts
        └── [component].test.tsx

components/
└── [component]/
    ├── [component].tsx
    └── [component].test.tsx
```

### 3. Database Testing Strategy
- Use **Testcontainers** for real PostgreSQL in CI/CD
- **Fallback to mocks** when Docker unavailable (local development)
- **Clean database** between tests to ensure isolation
- **Seed test data** programmatically through services

### 4. Authentication Testing
- Mock Better Auth session objects for API tests
- Use MSW to mock auth endpoints for component tests
- Test both authenticated and unauthenticated scenarios

### 5. External Service Testing
- **Always mock external APIs** (Gemini, R2) in tests
- Use MSW for HTTP-based external services
- Provide realistic mock responses for different scenarios

This comprehensive testing strategy ensures high code quality, maintainability, and confidence in deployments while providing fast feedback during development.