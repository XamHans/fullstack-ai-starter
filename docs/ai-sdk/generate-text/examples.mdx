---
title: "Generate Text Examples"
description: "Real-world code examples and use cases for AI text generation. Copy-paste ready implementations for content creation, documentation, and business applications."
---

## Content Creation

### Blog Post Generator

Generate complete blog posts with structured content:

<CodeGroup>

```typescript React Component
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

interface BlogPostData {
  title: string;
  introduction: string;
  sections: Array<{
    heading: string;
    content: string;
  }>;
  conclusion: string;
  tags: string[];
}

export function BlogPostGenerator() {
  const [topic, setTopic] = useState('');
  const [blogPost, setBlogPost] = useState<BlogPostData | null>(null);
  const [loading, setLoading] = useState(false);

  const generateBlogPost = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/generate-blog-post', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic }),
      });

      const data = await response.json();
      setBlogPost(data.blogPost);
    } catch (error) {
      console.error('Failed to generate blog post:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6 space-y-6">
      <div className="flex gap-2">
        <Input
          placeholder="Enter blog post topic..."
          value={topic}
          onChange={(e) => setTopic(e.target.value)}
          className="flex-1"
        />
        <Button onClick={generateBlogPost} disabled={loading || !topic}>
          {loading ? 'Generating...' : 'Generate Blog Post'}
        </Button>
      </div>

      {blogPost && (
        <Card className="p-6">
          <h1 className="text-3xl font-bold mb-4">{blogPost.title}</h1>

          <div className="mb-6">
            {blogPost.tags.map((tag) => (
              <Badge key={tag} variant="secondary" className="mr-2">
                {tag}
              </Badge>
            ))}
          </div>

          <div className="prose dark:prose-invert max-w-none">
            <p className="lead">{blogPost.introduction}</p>

            {blogPost.sections.map((section, index) => (
              <div key={index}>
                <h2>{section.heading}</h2>
                <p>{section.content}</p>
              </div>
            ))}

            <h2>Conclusion</h2>
            <p>{blogPost.conclusion}</p>
          </div>
        </Card>
      )}
    </div>
  );
}
```

```typescript API Route
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';
import { withAuthentication } from '@/lib/api/base';

export const POST = withAuthentication(async (session, req) => {
  const { topic } = await req.json();

  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Write a comprehensive blog post about "${topic}".

    Structure the response as JSON with this format:
    {
      "title": "Engaging blog post title",
      "introduction": "Hook the reader with an engaging introduction",
      "sections": [
        {
          "heading": "Section heading",
          "content": "Detailed section content"
        }
      ],
      "conclusion": "Summarize key points and call to action",
      "tags": ["relevant", "tags", "here"]
    }

    Make it informative, engaging, and well-structured.`,
    maxTokens: 2000,
  });

  const blogPost = JSON.parse(text);
  return { blogPost };
});
```

</CodeGroup>

### Product Description Generator

Create compelling product descriptions for e-commerce:

<CodeGroup>

```typescript Hook
import { useState } from 'react';

interface ProductInfo {
  name: string;
  category: string;
  features: string[];
  targetAudience: string;
}

interface ProductDescription {
  headline: string;
  description: string;
  features: string[];
  benefits: string[];
  callToAction: string;
}

export function useProductDescriptionGenerator() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const generateDescription = async (
    product: ProductInfo
  ): Promise<ProductDescription | null> => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/generate-product-description', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ product }),
      });

      if (!response.ok) {
        throw new Error('Failed to generate description');
      }

      const data = await response.json();
      return data.description;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
      return null;
    } finally {
      setLoading(false);
    }
  };

  return { generateDescription, loading, error };
}
```

```typescript Usage Example
function ProductDescriptionForm() {
  const { generateDescription, loading } = useProductDescriptionGenerator();
  const [result, setResult] = useState<ProductDescription | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    const productInfo = {
      name: 'Smart Fitness Watch',
      category: 'Wearable Technology',
      features: ['Heart Rate Monitor', 'GPS Tracking', '7-day Battery'],
      targetAudience: 'Fitness enthusiasts and health-conscious individuals'
    };

    const description = await generateDescription(productInfo);
    setResult(description);
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Form fields */}
      <Button type="submit" disabled={loading}>
        {loading ? 'Generating...' : 'Generate Description'}
      </Button>

      {result && (
        <div className="mt-6">
          <h3 className="text-xl font-bold">{result.headline}</h3>
          <p className="mt-2">{result.description}</p>
          {/* Render other fields */}
        </div>
      )}
    </form>
  );
}
```

</CodeGroup>

## Code Documentation

### API Documentation Generator

Automatically generate API documentation from code:

```typescript
interface APIEndpoint {
  method: string;
  path: string;
  description: string;
  parameters: Array<{
    name: string;
    type: string;
    required: boolean;
    description: string;
  }>;
  responses: Array<{
    status: number;
    description: string;
    example: any;
  }>;
}

async function generateAPIDoc(
  functionCode: string,
  endpoint: string
): Promise<APIEndpoint> {
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Analyze this API endpoint code and generate comprehensive documentation:

    Endpoint: ${endpoint}
    Code: ${functionCode}

    Generate a JSON response with the following structure:
    {
      "method": "GET|POST|PUT|DELETE",
      "path": "/api/endpoint",
      "description": "Clear description of what this endpoint does",
      "parameters": [
        {
          "name": "paramName",
          "type": "string|number|boolean|object",
          "required": true|false,
          "description": "What this parameter does"
        }
      ],
      "responses": [
        {
          "status": 200,
          "description": "Success response description",
          "example": { "sample": "response" }
        }
      ]
    }`,
    maxTokens: 1500,
  });

  return JSON.parse(text);
}
```

### README Generator

Create comprehensive README files for projects:

```typescript
interface ProjectInfo {
  name: string;
  description: string;
  technologies: string[];
  features: string[];
  installation: string[];
  usage: string;
}

async function generateREADME(projectInfo: ProjectInfo): Promise<string> {
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Create a comprehensive README.md file for this project:

    Project Name: ${projectInfo.name}
    Description: ${projectInfo.description}
    Technologies: ${projectInfo.technologies.join(', ')}
    Features: ${projectInfo.features.join(', ')}
    Installation Steps: ${projectInfo.installation.join(', ')}
    Usage: ${projectInfo.usage}

    Include:
    - Project title and description
    - Features list
    - Installation instructions
    - Usage examples
    - API documentation if applicable
    - Contributing guidelines
    - License information

    Use proper markdown formatting with badges, code blocks, and sections.`,
    maxTokens: 2500,
  });

  return text;
}
```

## Creative Writing

### Story Generator with Character Development

Create engaging stories with consistent character development:

<CodeGroup>

```typescript Story Generator
interface StorySettings {
  genre: string;
  setting: string;
  mainCharacter: string;
  conflict: string;
  tone: string;
}

interface GeneratedStory {
  title: string;
  characters: Array<{
    name: string;
    role: string;
    traits: string[];
  }>;
  chapters: Array<{
    title: string;
    content: string;
    wordCount: number;
  }>;
}

export async function generateStory(
  settings: StorySettings
): Promise<GeneratedStory> {
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Create a ${settings.genre} story with the following elements:

    Setting: ${settings.setting}
    Main Character: ${settings.mainCharacter}
    Central Conflict: ${settings.conflict}
    Tone: ${settings.tone}

    Structure the response as JSON:
    {
      "title": "Story title",
      "characters": [
        {
          "name": "Character name",
          "role": "protagonist|antagonist|supporting",
          "traits": ["trait1", "trait2", "trait3"]
        }
      ],
      "chapters": [
        {
          "title": "Chapter title",
          "content": "Chapter content (500-800 words)",
          "wordCount": 650
        }
      ]
    }

    Create 3-5 chapters with strong character development and plot progression.`,
    maxTokens: 4000,
  });

  return JSON.parse(text);
}
```

```typescript React Component
function StoryGenerator() {
  const [settings, setSettings] = useState<StorySettings>({
    genre: 'science fiction',
    setting: 'a distant planet',
    mainCharacter: 'a young explorer',
    conflict: 'discovery of ancient alien technology',
    tone: 'adventurous and mysterious'
  });

  const [story, setStory] = useState<GeneratedStory | null>(null);
  const [loading, setLoading] = useState(false);

  const handleGenerate = async () => {
    setLoading(true);
    try {
      const generatedStory = await generateStory(settings);
      setStory(generatedStory);
    } catch (error) {
      console.error('Story generation failed:', error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-4xl mx-auto p-6">
      {/* Settings form */}
      <div className="grid grid-cols-2 gap-4 mb-6">
        <Input
          placeholder="Genre"
          value={settings.genre}
          onChange={(e) => setSettings(prev => ({
            ...prev,
            genre: e.target.value
          }))}
        />
        {/* Other inputs */}
      </div>

      <Button onClick={handleGenerate} disabled={loading}>
        {loading ? 'Creating Story...' : 'Generate Story'}
      </Button>

      {story && (
        <div className="mt-8">
          <h1 className="text-4xl font-bold mb-6">{story.title}</h1>

          <div className="mb-8">
            <h2 className="text-2xl font-semibold mb-4">Characters</h2>
            {story.characters.map((character, index) => (
              <div key={index} className="mb-4 p-4 border rounded">
                <h3 className="font-bold">{character.name}</h3>
                <p className="text-sm text-gray-600">{character.role}</p>
                <p>{character.traits.join(', ')}</p>
              </div>
            ))}
          </div>

          <div>
            {story.chapters.map((chapter, index) => (
              <div key={index} className="mb-8">
                <h2 className="text-2xl font-semibold mb-4">
                  {chapter.title}
                </h2>
                <p className="whitespace-pre-wrap leading-relaxed">
                  {chapter.content}
                </p>
                <p className="text-sm text-gray-500 mt-2">
                  Word count: {chapter.wordCount}
                </p>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
```

</CodeGroup>

## Business Communication

### Email Templates

Generate professional emails for various business scenarios:

```typescript
interface EmailRequest {
  type: 'follow-up' | 'proposal' | 'meeting' | 'update' | 'apology';
  recipient: string;
  context: string;
  tone: 'formal' | 'friendly' | 'urgent' | 'casual';
  keyPoints: string[];
}

interface GeneratedEmail {
  subject: string;
  body: string;
  callToAction?: string;
}

async function generateBusinessEmail(
  request: EmailRequest
): Promise<GeneratedEmail> {
  const { text } = await generateText({
    model: openai('gpt-3.5-turbo'),
    prompt: `Generate a ${request.tone} ${request.type} email:

    Recipient: ${request.recipient}
    Context: ${request.context}
    Key Points: ${request.keyPoints.join(', ')}

    Return as JSON:
    {
      "subject": "Clear, actionable subject line",
      "body": "Well-structured email body with proper greeting and closing",
      "callToAction": "Clear next step or action item"
    }

    Keep it professional, concise, and actionable.`,
    maxTokens: 800,
  });

  return JSON.parse(text);
}

// Usage example
const emailRequest: EmailRequest = {
  type: 'follow-up',
  recipient: 'Sarah Johnson, Project Manager',
  context: 'Following up on last week\'s meeting about the Q4 marketing campaign',
  tone: 'friendly',
  keyPoints: [
    'Need budget approval by Friday',
    'Creative assets are ready for review',
    'Timeline depends on stakeholder feedback'
  ]
};

const email = await generateBusinessEmail(emailRequest);
console.log(email.subject); // "Follow-up: Q4 Marketing Campaign Next Steps"
```

### Meeting Notes & Action Items

Convert meeting transcripts into structured notes:

```typescript
async function generateMeetingNotes(transcript: string): Promise<{
  summary: string;
  keyDecisions: string[];
  actionItems: Array<{
    task: string;
    assignee: string;
    deadline: string;
    priority: 'high' | 'medium' | 'low';
  }>;
  nextSteps: string[];
}> {
  const { text } = await generateText({
    model: openai('gpt-4'),
    prompt: `Analyze this meeting transcript and extract structured information:

    ${transcript}

    Return as JSON:
    {
      "summary": "Brief meeting summary (2-3 sentences)",
      "keyDecisions": ["Decision 1", "Decision 2"],
      "actionItems": [
        {
          "task": "Specific task description",
          "assignee": "Person responsible",
          "deadline": "When it's due",
          "priority": "high|medium|low"
        }
      ],
      "nextSteps": ["Next step 1", "Next step 2"]
    }`,
    maxTokens: 1500,
  });

  return JSON.parse(text);
}
```

## Advanced Patterns

### Multi-step Content Generation

Break complex content into manageable steps:

```typescript
async function generateMarketingCampaign(productInfo: {
  name: string;
  target_audience: string;
  key_benefits: string[];
}): Promise<{
  strategy: string;
  headlines: string[];
  socialPosts: string[];
  emailSequence: string[];
}> {
  // Step 1: Generate strategy
  const { text: strategy } = await generateText({
    model: openai('gpt-4'),
    prompt: `Create a marketing strategy for ${productInfo.name} targeting ${productInfo.target_audience}. Key benefits: ${productInfo.key_benefits.join(', ')}`,
    maxTokens: 1000,
  });

  // Step 2: Generate headlines based on strategy
  const { text: headlinesText } = await generateText({
    model: openai('gpt-3.5-turbo'),
    prompt: `Based on this marketing strategy: "${strategy.slice(0, 500)}"

    Generate 10 compelling headlines for ${productInfo.name}. Return as JSON array.`,
    maxTokens: 500,
  });

  // Step 3: Generate social media posts
  const { text: socialPostsText } = await generateText({
    model: openai('gpt-3.5-turbo'),
    prompt: `Create 5 social media posts for ${productInfo.name} based on these headlines: ${headlinesText}. Make them engaging and platform-appropriate.`,
    maxTokens: 800,
  });

  // Step 4: Generate email sequence
  const { text: emailSequenceText } = await generateText({
    model: openai('gpt-4'),
    prompt: `Create a 3-email nurture sequence for ${productInfo.name}. Base it on the strategy: "${strategy.slice(0, 300)}"`,
    maxTokens: 1200,
  });

  return {
    strategy,
    headlines: JSON.parse(headlinesText),
    socialPosts: JSON.parse(socialPostsText),
    emailSequence: JSON.parse(emailSequenceText),
  };
}
```

## Error Handling Patterns

### Robust Error Handling with Fallbacks

```typescript
async function generateTextWithFallback(
  prompt: string,
  options: {
    maxRetries?: number;
    fallbackModel?: string;
    fallbackResponse?: string;
  } = {}
): Promise<string> {
  const {
    maxRetries = 3,
    fallbackModel = 'gpt-3.5-turbo',
    fallbackResponse = 'I apologize, but I cannot generate content right now. Please try again later.'
  } = options;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const model = attempt === 1 ? 'gpt-4' : fallbackModel;

      const { text } = await generateText({
        model: openai(model),
        prompt,
        maxTokens: 1000,
      });

      return text;
    } catch (error) {
      console.error(`Attempt ${attempt} failed:`, error);

      if (attempt === maxRetries) {
        // Final fallback
        return fallbackResponse;
      }

      // Wait before retry (exponential backoff)
      await new Promise(resolve =>
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }

  return fallbackResponse;
}
```

<Note>
These examples demonstrate production-ready patterns that you can adapt to your specific needs. Each includes proper error handling, TypeScript types, and follows the established patterns in your application.
</Note>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Try the Playground"
    icon="play"
    href="/playground/generate-text"
  >
    Test these examples in our interactive playground environment.
  </Card>
  <Card
    title="API Reference"
    icon="book"
    href="/ai-sdk/generate-text/api-reference"
  >
    Explore all available parameters and configuration options.
  </Card>
  <Card
    title="Best Practices"
    icon="lightbulb"
    href="/ai-sdk/best-practices"
  >
    Learn optimization techniques and production deployment strategies.
  </Card>
  <Card
    title="Architecture Guide"
    icon="sitemap"
    href="/architecture/api-architecture"
  >
    Understand how AI SDK integrates with the application's architecture.
  </Card>
</CardGroup>